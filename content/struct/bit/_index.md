---
title: Bit Indexed Tree
version: 1.0
prefix: $bit
weight: 204
---

{{< meta >}}

区間に対する和を高速に処理するデータ構造です。

## 説明
配列 $A$ に対して、要素に対する加算と区間に対する和を何回も処理する場合に有用なデータ構造です。
通常の配列の場合、要素に対する加算は容易に $O(1)$ で処理できますが、区間に対する演算の計算量はその区間の長さに比例します。
Bit Indexed Tree(BIT)は、要素に対する加算を $O(\log |A|)$ とする代わりに、区間に対する演算の計算量も $O(\log |A|)$ に抑えます。
区間に対して、より一般的な演算を施したい場合は [セグメント木]({{< ref "struct/segt/_index.md" >}}) を使用してください。

## データ構造

### ジェネリクス
$T \subseteq \mathbb{R}$ s.t. $T$ は加法で閉じている。

### 状態空間
- $n' \in \mathbb{Z}_{+}$
- $A' = (A_{0}', \ldots, A_{n' - 1}') \in T^{n'}$

$A'$ は配列の各要素の状態に対応します。この配列は0-indexedです。

### コンストラクタ
要素数 $n$ のBITを初期化します。要素数は2のべき乗である必要はありません。
BITの各要素は0で初期化されます。

#### 引数
$n \in \mathbb{Z}_{+}$

#### 初期状態
- $n' = n$
- $A' = (0, \ldots, 0)$

#### 計算量
$O(n)$

### add
指定した要素に値を加算します。指定するインデックスは0-indexedです。

#### 引数
- $i \in \\{ 0, 1, \ldots, n' - 1 \\}$
- $x \in T$

#### 戻り値
なし

#### 状態変化
$A_{i}' \leftarrow A_{i}' + x$

#### 計算量
$O(\log{n'})$

### sum
0番目から $i$ 番目まで（$i$ 番目は含まない）の和を返します。区間は右開区間であり、インデックスは0-indexedです。
なお $i$ 番目から $j$ 番目までの和は $sum(j) - sum(i)$ で求めることができます。

#### 引数
- $i \in \\{ 0, 1, \ldots, n' \\}$

#### 戻り値
$\sum_{k = 0}^{i - 1} A'_{k}$

#### 状態変化
なし

#### 計算量
$O(\log{n'})$

{{< src >}}

{{< example >}}
